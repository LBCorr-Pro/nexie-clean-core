
const CACHE_NAME_PREFIX = 'nexie-cache';
const CACHE_VERSION = 'v1.2'; // Increment this to trigger cache updates
const CACHE_NAME = `${CACHE_NAME_PREFIX}-${CACHE_VERSION}`;

// Files to cache on install - typically your app shell
const APP_SHELL_URLS = [
  '/',
  '/?utm_source=pwa',
  '/manifest.json',
  // Add paths to your core static assets: CSS, JS, fonts, main logo
  // Example: '/_next/static/css/...', '/_next/static/chunks/...', '/fonts/...'
  // These paths are usually generated by Next.js build, so dynamic caching for these in fetch is often better
  // For a truly robust app shell, you'd need to know the exact output paths or use a build tool plugin
];

self.addEventListener('install', (event) => {
  console.log('[SW] Install event');
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      console.log('[SW] Caching app shell urls:', APP_SHELL_URLS);
      // It's okay if some of these fail (e.g., if APP_SHELL_URLS is empty or paths are dynamic)
      // A more robust approach for Next.js static assets is to cache them on first fetch.
      return cache.addAll(APP_SHELL_URLS.filter(url => url !== '/')).catch(err => {
        console.warn('[SW] Failed to cache some app shell URLs during install:', err);
      });
    }).then(() => self.skipWaiting()) // Activate new SW immediately
  );
});

self.addEventListener('activate', (event) => {
  console.log('[SW] Activate event');
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName.startsWith(CACHE_NAME_PREFIX) && cacheName !== CACHE_NAME) {
            console.log('[SW] Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
          return null;
        })
      );
    }).then(() => self.clients.claim()) // Take control of all open clients
  );
});

self.addEventListener('fetch', (event) => {
  const request = event.request;
  // console.log('[SW] Fetch event for:', request.url);

  // Ignore non-GET requests
  if (request.method !== 'GET') {
    // console.log('[SW] Ignoring non-GET request:', request.method, request.url);
    event.respondWith(fetch(request));
    return;
  }

  // Ignore Firebase Firestore requests & auth requests
  if (request.url.includes('firestore.googleapis.com') || request.url.includes('firebaseapp.com')) {
    // console.log('[SW] Ignoring Firebase request:', request.url);
    event.respondWith(fetch(request));
    return;
  }
  
  // For Next.js specific paths (data, static chunks), prioritize network to ensure freshness,
  // but fall back to cache. These are often versioned, so caching them once is fine.
  if (request.url.includes('/_next/static/') || request.url.includes('/_next/data/')) {
    event.respondWith(
      caches.open(CACHE_NAME).then((cache) => {
        return cache.match(request).then((cachedResponse) => {
          const fetchPromise = fetch(request).then((networkResponse) => {
            // Check if we received a valid response
            if (networkResponse && networkResponse.status === 200) {
              cache.put(request, networkResponse.clone());
            }
            return networkResponse;
          }).catch(error => {
            console.warn('[SW] Network request failed for Next.js asset:', request.url, error);
            // If network fails and we have a cached response, return it
            if (cachedResponse) return cachedResponse;
            // Otherwise, re-throw the error to let the browser handle it
            throw error;
          });

          // Return cached response immediately if available, and update cache in background
          return cachedResponse || fetchPromise;
        });
      })
    );
    return;
  }

  // Network first, then cache strategy for HTML pages and other important resources
  if (request.headers.get('accept')?.includes('text/html') || APP_SHELL_URLS.includes(new URL(request.url).pathname)) {
    event.respondWith(
      caches.open(CACHE_NAME).then((cache) => {
        return fetch(request)
          .then((networkResponse) => {
            // Check if we received a valid response
            if (networkResponse && networkResponse.status === 200) {
              // console.log('[SW] Caching network response for:', request.url);
              cache.put(request, networkResponse.clone());
            }
            return networkResponse;
          })
          .catch(() => {
            // console.log('[SW] Network failed, trying cache for:', request.url);
            return cache.match(request).then((cachedResponse) => {
              if (cachedResponse) {
                return cachedResponse;
              }
              // If not in cache and network failed, you might want a fallback offline page
              // For now, just let the browser handle the error (resulting in an offline error page)
              console.warn('[SW] Resource not in cache and network failed:', request.url);
              return new Response("Network error: Content not available offline.", {
                status: 404,
                statusText: "Content not available offline.",
                headers: { 'Content-Type': 'text/plain' }
              });
            });
          });
      })
    );
    return;
  }
  
  // Cache first for other assets (images, fonts not part of _next/static)
  event.respondWith(
    caches.open(CACHE_NAME).then((cache) => {
      return cache.match(request).then((response) => {
        if (response) {
          // console.log('[SW] Serving from cache:', request.url);
          return response;
        }
        // console.log('[SW] Fetching and caching new resource:', request.url);
        return fetch(request).then((networkResponse) => {
          if (networkResponse && networkResponse.status === 200) {
            cache.put(request, networkResponse.clone());
          }
          return networkResponse;
        });
      });
    })
  );
});
